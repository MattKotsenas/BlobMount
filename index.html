<!DOCTYPE html />

<html>
<head>
	<title>WindowsAzureBlobFS.cs</title>
	<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
	<link href="nocco.css" rel="stylesheet" media="all" type="text/css" />
	<script src="prettify.js" type="text/javascript"></script>
</head>
<body onload="prettyPrint()">
	<div id="container">
		<div id="background"></div>
		<table cellpadding="0" cellspacing="0">
			<thead>
				<tr>
					<th class="docs">
						<h1>WindowsAzureBlobFS.cs</h1>
					</th>
					<th class="code"></th>
				</tr>
			</thead>
			<tbody>
					<tr id="section_1">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_1">&#182;</a>
							</div>
							<h2>DESCRIPTION</h2>

<p><strong>WindowsAzureBlobFS</strong> is a <a href="http://dokan-dev.net/en">Dokan</a> file system provider for Windows Azure blob storage accounts.
Full source code is at <a href="http://github.com/smarx/BlobMount">http://github.com/smarx/BlobMount</a>.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>
</code></pre>
						</td>
					</tr>
					<tr id="section_2">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_2">&#182;</a>
							</div>
							<h2>USAGE</h2>

<p>To use it, install <a href="http://dokan-dev.net/en/download/#dokan">Dokan</a> and run
<code>BlobMount &lt;mount-point&gt; &lt;account&gt; &lt;key&gt;</code>. E.g. <code>BlobMount w:\ myaccount EbhC5+NTN...==</code></p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>
</code></pre>
						</td>
					</tr>
					<tr id="section_3">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_3">&#182;</a>
							</div>
							<p>Top-level directories under the mount point are containers in blob storage. Lower-level directories are blob prefixes ('/'-delimited).
Files are blobs.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>
</code></pre>
						</td>
					</tr>
					<tr id="section_4">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_4">&#182;</a>
							</div>
							<p><strong>NOTE:</strong> Because Windows Azure blob storage doesn't have a notion of explicit "directories," empty directories are currently
ephemeral. They don't exist in blob storage, but only in memory for the duration of the mounted drive. That means any empty directories
will vanish when the drive is unmounted. It may be better to do something like persist the "empty directories" via blobs with metadata
(IsEmptyDirectory=true).</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>
</code></pre>
						</td>
					</tr>
					<tr id="section_5">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_5">&#182;</a>
							</div>
							<h2>SCARY STATUS</h2>

<p>Plenty of work left. See all the TODOs in the code. :-) This is alpha code and probably works for a single user editing some blobs. Don't hold me
responsible for data loss... have a backup for sure. Lots of places in this code only implement the paths I've tested. Things like
seeking within a file during a write may totally destroy data. Consider yourself warned.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>using System;
using System.Collections.Generic;
using System.Collections;
using System.Linq;
using System.Text;
using Dokan;
using System.IO;
using Microsoft.WindowsAzure.StorageClient;
using Microsoft.WindowsAzure;

namespace BlobMount
{
    public class WindowsAzureBlobFS : DokanOperations
    {
</code></pre>
						</td>
					</tr>
					<tr id="section_6">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_6">&#182;</a>
							</div>
							<p>Mount takes the following arguments:</p>

<ul>
<li>Mount point</li>
<li>Storage account</li>
<li>Storage key</li>
</ul>

<p>Translates Dokan error messages to friendly text.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>        public static void Mount(string[] args)
        {
            switch (DokanNet.DokanMain(new DokanOptions
            {
                MountPoint = args[0],
                DebugMode = true,
                UseStdErr = true,
                VolumeLabel = &quot;WindowsAzureBlobDrive&quot;
            }, new WindowsAzureBlobFS(args[1], args[2])))
            {
                case DokanNet.DOKAN_DRIVE_LETTER_ERROR:
                    Console.WriteLine(&quot;Drive letter error&quot;);
                    break;
                case DokanNet.DOKAN_DRIVER_INSTALL_ERROR:
                    Console.WriteLine(&quot;Driver install error&quot;);
                    break;
                case DokanNet.DOKAN_MOUNT_ERROR:
                    Console.WriteLine(&quot;Mount error&quot;);
                    break;
                case DokanNet.DOKAN_START_ERROR:
                    Console.WriteLine(&quot;Start error&quot;);
                    break;
                case DokanNet.DOKAN_ERROR:
                    Console.WriteLine(&quot;Unknown error&quot;);
                    break;
                case DokanNet.DOKAN_SUCCESS:
                    Console.WriteLine(&quot;Success&quot;);
                    break;
                default:
                    Console.WriteLine(&quot;Unknown status&quot;);
                    break;
            }
        }

        private CloudBlobClient blobs;

</code></pre>
						</td>
					</tr>
					<tr id="section_7">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_7">&#182;</a>
							</div>
							<p>Initialize with a cloud storage account and key.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>        public WindowsAzureBlobFS(string account, string key)
        {
            blobs = new CloudStorageAccount(new StorageCredentialsAccountAndKey(account, key), false).CreateCloudBlobClient();
        }

</code></pre>
						</td>
					</tr>
					<tr id="section_8">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_8">&#182;</a>
							</div>
							<p>Close the corresponding BlobStream, if any, to commit the changes.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>        public int Cleanup(string filename, DokanFileInfo info)
        {
            if (readBlobs.ContainsKey(filename)) readBlobs[filename].Close();
            if (writeBlobs.ContainsKey(filename)) writeBlobs[filename].Close();
            return 0;
        }

</code></pre>
						</td>
					</tr>
					<tr id="section_9">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_9">&#182;</a>
							</div>
							<p>Call close on the underlying BlobStream (if any) so writes are committed and buffered reads are discarded.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>        public int CloseFile(string filename, DokanFileInfo info)
        {
            if (writeBlobs.ContainsKey(filename))
            {
                writeBlobs[filename].Close();
                writeBlobs.Remove(filename);
            }
            if (readBlobs.ContainsKey(filename))
            {
                readBlobs[filename].Close();
                readBlobs.Remove(filename);
            }
            return 0;
        }

</code></pre>
						</td>
					</tr>
					<tr id="section_10">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_10">&#182;</a>
							</div>
							<p>Keep track of empty directories (in memory).</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>        private HashSet&lt;string&gt; emptyDirectories = new HashSet&lt;string&gt;();
        private IEnumerable&lt;string&gt; EnumeratePathAndParents(string directory)
        {
            var split = directory.Split(new [] { &#39;\\&#39; }, StringSplitOptions.RemoveEmptyEntries);
            var path = &quot;\\&quot; + split.FirstOrDefault() ?? &quot;&quot;;
            foreach (var segment in split.Skip(1))
            {
                path += &quot;\\&quot; + segment;
                yield return path;
            }
        }
        private bool AddEmptyDirectories(string directory)
        {
            bool alreadyExisted = false;
            foreach (var path in EnumeratePathAndParents(directory))
            {
                alreadyExisted |= emptyDirectories.Add(path);
            }
            Console.WriteLine(&quot;emptyDirectories:\n\t&quot; + string.Join(&quot;\n\t&quot;, emptyDirectories));
            return alreadyExisted;
        }
        private void RemoveEmptyDirectories(string directory)
        {
            foreach (var path in EnumeratePathAndParents(directory))
            {
                emptyDirectories.Remove(path);
            }
            Console.WriteLine(&quot;emptyDirectories:\n\t&quot; + string.Join(&quot;\n\t&quot;, emptyDirectories));
        }

</code></pre>
						</td>
					</tr>
					<tr id="section_11">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_11">&#182;</a>
							</div>
							<p>CreateDirectory creates a container if at the top level and otherwise creates an empty directory (tracked in memory only).</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>        public int CreateDirectory(string filename, DokanFileInfo info)
        {
            var split = filename.Split(new[] { Path.DirectorySeparatorChar }, StringSplitOptions.RemoveEmptyEntries);

            if (split.Length == 1)
            {
                try
                {
                    blobs.GetContainerReference(split[0]).Create();
                }
                catch (StorageClientException e)
                {
                    if (e.ErrorCode == StorageErrorCode.ContainerAlreadyExists)
                    {
</code></pre>
						</td>
					</tr>
					<tr id="section_12">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_12">&#182;</a>
							</div>
							<p>TODO: This doesn't seem to give the right error message when I try to "md" a container that already exists.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>                        return -DokanNet.ERROR_ALREADY_EXISTS;
                    }
                    throw;
                }
                return 0;
            }
            else
            {
</code></pre>
						</td>
					</tr>
					<tr id="section_13">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_13">&#182;</a>
							</div>
							<p>Use OpenDirectory as a way to test for existence of a directory.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>                if (OpenDirectory(filename, info) == 0)
                {
                    return -DokanNet.ERROR_ALREADY_EXISTS;
                }
                else
                {
</code></pre>
						</td>
					</tr>
					<tr id="section_14">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_14">&#182;</a>
							</div>
							<p>Track the empty directory in memory.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>                    if (!AddEmptyDirectories(filename))
                    {
                        return -DokanNet.ERROR_ALREADY_EXISTS;
                    }
                    else
                    {
                        return 0;
                    }
                }
            }
        }

</code></pre>
						</td>
					</tr>
					<tr id="section_15">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_15">&#182;</a>
							</div>
							<p>Create file does nothing except validate that the file requested is okay to create.
Actual creation of a corresponding blob in cloud storage is done when the file is actually written.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>        public int CreateFile(string filename, FileAccess access, FileShare share, FileMode mode, FileOptions options, DokanFileInfo info)
        {
</code></pre>
						</td>
					</tr>
					<tr id="section_16">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_16">&#182;</a>
							</div>
							<p>When trying to open a file for reading, succeed only if the file already exists.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>            if (mode == FileMode.Open &amp;&amp; (access == FileAccess.Read || access == FileAccess.ReadWrite))
            {
                if (GetFileInformation(filename, new FileInformation(), new DokanFileInfo(0)) == 0)
                {
                    return 0;
                }
                else
                {
                    return -DokanNet.ERROR_FILE_NOT_FOUND;
                }
            }
</code></pre>
						</td>
					</tr>
					<tr id="section_17">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_17">&#182;</a>
							</div>
							<p>When creating a file, always succeed. (Empty directories will be implicitly created as needed.)</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>            else if (mode == FileMode.Create || mode == FileMode.OpenOrCreate)
            {
</code></pre>
						</td>
					</tr>
					<tr id="section_18">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_18">&#182;</a>
							</div>
							<p>Since we're creating a file, we don't need to track the parents (up the tree) as empty directories any longer.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>                RemoveEmptyDirectories(Path.GetDirectoryName(filename));
                return 0;
            }
            else
            {
                throw new NotImplementedException();
            }
        }

</code></pre>
						</td>
					</tr>
					<tr id="section_19">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_19">&#182;</a>
							</div>
							<p>DeleteDirectory removes a container if it's at the root level, fails if a directory is not empty,
and removes a tracked empty directory if one exists.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>        public int DeleteDirectory(string filename, DokanFileInfo info)
        {
            var split = filename.Trim(&#39;\\&#39;).Split(Path.DirectorySeparatorChar);
            if (split.Length == 1)
            {
                try
                {
                    blobs.GetContainerReference(split[0]).Delete();
                    return 0;
                }
                catch { return -1; }
            }
            if (blobs.ListBlobsWithPrefix(filename.Trim(&#39;\\&#39;).Replace(&#39;\\&#39;, &#39;/&#39;)).Any())
            {
</code></pre>
						</td>
					</tr>
					<tr id="section_20">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_20">&#182;</a>
							</div>
							<p>TODO: Revisit what a better error code might be.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>                return -1;
            }
            else if (emptyDirectories.Any(f =&gt; f.StartsWith(filename + &quot;\\&quot;)))
            {
</code></pre>
						</td>
					</tr>
					<tr id="section_21">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_21">&#182;</a>
							</div>
							<p>TODO: Revisit what a better error code might be.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>                return -1;
            }
            else
            {
                emptyDirectories.Remove(filename);
                return 0;
            }
        }

</code></pre>
						</td>
					</tr>
					<tr id="section_22">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_22">&#182;</a>
							</div>
							<p>DeleteFile tries to delete the corresponding blob and ensures the parent directory is tracked as empty.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>        public int DeleteFile(string filename, DokanFileInfo info)
        {
            try
            {
                blobs.GetBlobReference(filename.Trim(&#39;\\&#39;)).Delete();
                if (!blobs.ListBlobsWithPrefix(Path.GetDirectoryName(filename).Trim(&#39;\\&#39;).Replace(&#39;\\&#39;, &#39;/&#39;)).Any())
                {
                    AddEmptyDirectories(Path.GetDirectoryName(filename));
                }
                return 0;
            }
            catch { return -1; }
        }

</code></pre>
						</td>
					</tr>
					<tr id="section_23">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_23">&#182;</a>
							</div>
							<p>FindFiles enumerates blobs and blob prefixes and represents them as files and directories.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>        public int FindFiles(string filename, ArrayList files, DokanFileInfo info)
        {
            if (filename == &quot;\\&quot;)
            {
                files.AddRange(blobs.ListContainers().Select(c =&gt; new FileInformation
                {
                    FileName = c.Name,
                    Attributes = FileAttributes.Directory,
                    CreationTime = c.Properties.LastModifiedUtc,
                    LastAccessTime = c.Properties.LastModifiedUtc,
                    LastWriteTime = c.Properties.LastModifiedUtc
                }).ToList());
            }
            else
            {
                var split = filename.Trim(&#39;\\&#39;).Split(Path.DirectorySeparatorChar);
                var container = blobs.GetContainerReference(split[0]);
                IEnumerable&lt;IListBlobItem&gt; items =
                    split.Length &gt; 1
                    ? container.GetDirectoryReference(string.Join(&quot;/&quot;, split.Skip(1).Take(split.Length - 1))).ListBlobs()
                    : container.ListBlobs();
                files.AddRange(items.Select(c =&gt; new FileInformation
                {
                    FileName = c.Uri.AbsolutePath.Substring(filename.Length + 1).TrimEnd(&#39;/&#39;),
                    Attributes = (c is CloudBlobDirectory) ? FileAttributes.Directory : FileAttributes.Normal,
                    CreationTime = (c is CloudBlob) ? ((CloudBlob)c).Properties.LastModifiedUtc : DateTime.UtcNow,
                    LastAccessTime = (c is CloudBlob) ? ((CloudBlob)c).Properties.LastModifiedUtc : DateTime.UtcNow,
                    LastWriteTime = (c is CloudBlob) ? ((CloudBlob)c).Properties.LastModifiedUtc : DateTime.UtcNow,
                    Length = (c is CloudBlob) ? ((CloudBlob)c).Properties.Length : 0
                }).ToList());
                files.AddRange(emptyDirectories.Where(f =&gt; f.StartsWith(filename + &quot;\\&quot;) &amp;&amp; !f.Substring(filename.Length + 1).Contains(&quot;\\&quot;)).Select(f =&gt; new FileInformation
                {
                    FileName = f.Substring(filename.Length + 1),
                    Attributes = FileAttributes.Directory,
                    CreationTime = DateTime.UtcNow,
                    LastAccessTime = DateTime.UtcNow,
                    LastWriteTime = DateTime.UtcNow,
                    Length = 0
                }).ToList());
            }
            return 0;
        }

        public int FlushFileBuffers(string filename, DokanFileInfo info)
        {
            return 0;
        }

</code></pre>
						</td>
					</tr>
					<tr id="section_24">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_24">&#182;</a>
							</div>
							<p>GetDiskFreeSpace returns hardcoded values.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>        public int GetDiskFreeSpace(ref ulong freeBytesAvailable, ref ulong totalBytes, ref ulong totalFreeBytes, DokanFileInfo info)
        {
            freeBytesAvailable = 512 * 1024 * 1024;
            totalBytes = 1024 * 1024 * 1024;
            totalFreeBytes = 512 * 1024 * 1024;
            return 0;
        }

</code></pre>
						</td>
					</tr>
					<tr id="section_25">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_25">&#182;</a>
							</div>
							<p>GetFileInformation returns information about a container at the top level, blob prefixes at lower levels,
and empty directories (tracked in memory). File times are all specified as <code>DateTime.UtcNow</code>.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>        public int GetFileInformation(string filename, FileInformation fileinfo, DokanFileInfo info)
        {
            var split = filename.Split(new[] { Path.DirectorySeparatorChar }, StringSplitOptions.RemoveEmptyEntries);
            if (split.Length == 0)
            {
                fileinfo.Attributes = FileAttributes.Directory;
                fileinfo.CreationTime = DateTime.UtcNow;
                fileinfo.LastAccessTime = DateTime.UtcNow;
                fileinfo.LastWriteTime = DateTime.UtcNow;
                return 0;
            }
            if (split.Length == 1)
            {
                var container = blobs.ListContainers(split[0]).FirstOrDefault();
                if (container != null &amp;&amp; container.Name == split[0])
                {
                    fileinfo.Attributes = FileAttributes.Directory;
                    fileinfo.CreationTime = DateTime.UtcNow;
                    fileinfo.LastAccessTime = DateTime.UtcNow;
                    fileinfo.LastWriteTime = DateTime.UtcNow;
                    return 0;
                }
                else
                {
                    return -1;
                }
            }
            var blob = blobs.GetBlobReference(filename.Trim(&#39;\\&#39;));
            try
            {
                blob.FetchAttributes();
                fileinfo.CreationTime = blob.Properties.LastModifiedUtc;
                fileinfo.LastWriteTime = blob.Properties.LastModifiedUtc;
                fileinfo.LastAccessTime = DateTime.UtcNow;
                fileinfo.Length = blob.Properties.Length;
                return 0;
            }
            catch
            {
                if (emptyDirectories.Contains(filename) || blobs.ListBlobsWithPrefix(filename.Trim(&#39;\\&#39;).Replace(&#39;\\&#39;, &#39;/&#39;)).Any())
                {
                    fileinfo.Attributes = FileAttributes.Directory;
                    fileinfo.CreationTime = DateTime.UtcNow;
                    fileinfo.LastAccessTime = DateTime.UtcNow;
                    fileinfo.LastWriteTime = DateTime.UtcNow;
                    return 0;
                }
                else
                {
                    return -DokanNet.ERROR_FILE_NOT_FOUND;
                }
            }
        }

</code></pre>
						</td>
					</tr>
					<tr id="section_26">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_26">&#182;</a>
							</div>
							<p>TODO: Perhaps use leases on blobs to do locking?</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>        public int LockFile(string filename, long offset, long length, DokanFileInfo info)
        {
            return 0;
        }

</code></pre>
						</td>
					</tr>
					<tr id="section_27">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_27">&#182;</a>
							</div>
							<p>TODO: Use copy and then delete to do an efficient move where possible.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>        public int MoveFile(string filename, string newname, bool replace, DokanFileInfo info)
        {
            throw new NotImplementedException();
        }

</code></pre>
						</td>
					</tr>
					<tr id="section_28">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_28">&#182;</a>
							</div>
							<p>OpenDirectory succeeds as long as the specified path is an empty directory (tracked in memory)
or a blob prefix containing blobs (discovered via GetFileInformation returning a success code with a directory).</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>        public int OpenDirectory(string filename, DokanFileInfo info)
        {
            if (emptyDirectories.Contains(filename)) return 0;
            var fileinfo = new FileInformation();
            var status = GetFileInformation(filename, fileinfo, info);
            if ((status == 0) &amp;&amp; (fileinfo.Attributes == FileAttributes.Directory)) return 0;
            return -DokanNet.ERROR_FILE_NOT_FOUND;
        }

</code></pre>
						</td>
					</tr>
					<tr id="section_29">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_29">&#182;</a>
							</div>
							<p>Keep track of open streams for reading blobs. (Done this way instead of making an HTTP call for each read
operation so that we can do read-ahead (significant perf gain for normal operations like reading an entire file).</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>        private Dictionary&lt;string, BlobStream&gt; readBlobs = new Dictionary&lt;string, BlobStream&gt;();
        public int ReadFile(string filename, byte[] buffer, ref uint readBytes, long offset, DokanFileInfo info)
        {
            if (!readBlobs.ContainsKey(filename))
            {
                readBlobs[filename] = blobs.GetBlobReference(filename.Trim(&#39;\\&#39;)).OpenRead();
            }
            readBlobs[filename].Position = offset;
            readBytes = (uint)readBlobs[filename].Read(buffer, 0, buffer.Length);
            return 0;
        }

</code></pre>
						</td>
					</tr>
					<tr id="section_30">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_30">&#182;</a>
							</div>
							<p>TODO: Figure out what this is supposed to do and maybe do it. :)</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>        public int SetAllocationSize(string filename, long length, DokanFileInfo info)
        {
            return 0;
        }

</code></pre>
						</td>
					</tr>
					<tr id="section_31">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_31">&#182;</a>
							</div>
							<p>TODO: This is presumably to truncate a file? This could be implemented in the future.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>        public int SetEndOfFile(string filename, long length, DokanFileInfo info)
        {
            throw new NotImplementedException();
        }

</code></pre>
						</td>
					</tr>
					<tr id="section_32">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_32">&#182;</a>
							</div>
							<p>TODO: Consider implementing this.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>        public int SetFileAttributes(string filename, FileAttributes attr, DokanFileInfo info)
        {
            throw new NotImplementedException();
        }

</code></pre>
						</td>
					</tr>
					<tr id="section_33">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_33">&#182;</a>
							</div>
							<p>SetFileTime isn't supported, since we don't actually track meaningful times for most of this.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>        public int SetFileTime(string filename, DateTime ctime, DateTime atime, DateTime mtime, DokanFileInfo info)
        {
            throw new NotImplementedException();
        }

</code></pre>
						</td>
					</tr>
					<tr id="section_34">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_34">&#182;</a>
							</div>
							<p>TODO: Perhaps use leases on blobs to do locking?</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>        public int UnlockFile(string filename, long offset, long length, DokanFileInfo info)
        {
            return 0;
        }

</code></pre>
						</td>
					</tr>
					<tr id="section_35">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_35">&#182;</a>
							</div>
							<p>Close everything.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>        public int Unmount(DokanFileInfo info)
        {
            foreach (var filename in readBlobs.Keys) CloseFile(filename, info);
            foreach (var filename in writeBlobs.Keys) CloseFile(filename, info);
            return 0;
        }

        private Dictionary&lt;string, Stream&gt; writeBlobs = new Dictionary&lt;string, Stream&gt;();
        public int WriteFile(string filename, byte[] buffer, ref uint writtenBytes, long offset, DokanFileInfo info)
        {
            if (!writeBlobs.ContainsKey(filename))
            {
                var blob = blobs.GetBlockBlobReference(filename.TrimStart(&#39;\\&#39;));
                writeBlobs[filename] = blob.OpenWrite();
                if (offset != 0)
                {
                    blob.FetchAttributes();
                    if (offset == blob.Properties.Length)
                    {
</code></pre>
						</td>
					</tr>
					<tr id="section_36">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_36">&#182;</a>
							</div>
							<p>TODO: This is a really inefficient way to do this.
The right thing to do is to start writing new blocks and then commit <em>old blocks</em> + <em>new blocks</em>.
This method is okay for small files and "works."</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>                        var previousBytes = blob.DownloadByteArray();
                        writeBlobs[filename].Write(previousBytes, 0, previousBytes.Length);
                    }
                    else
                    {
</code></pre>
						</td>
					</tr>
					<tr id="section_37">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_37">&#182;</a>
							</div>
							<p>TODO: Handle arbitrary seeks during writing.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>                        throw new NotImplementedException();
                    }
                }
            }
            writeBlobs[filename].Write(buffer, 0, buffer.Length);
            writtenBytes = (uint)buffer.Length;
            return 0;
        }
    }

}
</code></pre>
						</td>
					</tr>
			</tbody>
		</table>
	</div>
</body>
</html>
